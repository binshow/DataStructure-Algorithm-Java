
//https://leetcode.cn/tag/sliding-window/problemset/



滑动窗口本质上就是一种动态规划，虽然和遍历所有子数组一个个试错没有本质区别，但是滑动窗口可以根据单调性把时间复杂度由平方级变成线性。
所谓单调性就是指类似【如果[i,j]不符合，则[0~i-1,j]是不用试，肯定不符合】这样的性质.

以【209.长度最小的子数组】为例：

给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。
如果不存在符合条件的子数组，返回 0 。

本来我需要遍历所有的子数组[i=0~m-1,i~m-1]，有m * (m+1) / 2个。

但当我滑动窗口时，比如遍历到右坐标j时，对应的左坐标是i，这个子数组即为[i,j]，总和为sm >= target。那么所有[0~i-1,j]的子数组全部不用考虑。
而遍历到下一个坐标j+1时，我不需要再去考虑[0~i-1,j+1]，因为新总和sm = sm + nums[j+1] >= target，而同时左坐标i可以往试图右移直到最后一个sm >= target。
由于这个i是可以继承的，每次遍历要么j+1，要么i+1，那么实际上遍历的子数组个数不会超过2 * m，利用单调性大幅度降低了遍历数量。

