package Algorithm.dfs;

public class _529_æ‰«é›·æ¸¸æˆ {


    //è®©æˆ‘ä»¬ä¸€èµ·æ¥ç©æ‰«é›·æ¸¸æˆï¼
    //
    //ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º m x n äºŒç»´å­—ç¬¦çŸ©é˜µ board ï¼Œè¡¨ç¤ºæ‰«é›·æ¸¸æˆçš„ç›˜é¢ï¼Œå…¶ä¸­ï¼š
    //
    //'M' ä»£è¡¨ä¸€ä¸ª æœªæŒ–å‡ºçš„ åœ°é›·ï¼Œ
    //'E' ä»£è¡¨ä¸€ä¸ª æœªæŒ–å‡ºçš„ ç©ºæ–¹å—ï¼Œ
    //'B' ä»£è¡¨æ²¡æœ‰ç›¸é‚»ï¼ˆä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³ï¼Œå’Œæ‰€æœ‰4ä¸ªå¯¹è§’çº¿ï¼‰åœ°é›·çš„ å·²æŒ–å‡ºçš„ ç©ºç™½æ–¹å—ï¼Œ
    //æ•°å­—ï¼ˆ'1' åˆ° '8'ï¼‰è¡¨ç¤ºæœ‰å¤šå°‘åœ°é›·ä¸è¿™å— å·²æŒ–å‡ºçš„ æ–¹å—ç›¸é‚»ï¼Œ
    //'X' åˆ™è¡¨ç¤ºä¸€ä¸ª å·²æŒ–å‡ºçš„ åœ°é›·ã€‚
    //ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ click ï¼Œå…¶ä¸­ click = [clickr, clickc] è¡¨ç¤ºåœ¨æ‰€æœ‰ æœªæŒ–å‡ºçš„ æ–¹å—ï¼ˆ'M' æˆ–è€… 'E'ï¼‰ä¸­çš„ä¸‹ä¸€ä¸ªç‚¹å‡»ä½ç½®ï¼ˆclickr æ˜¯è¡Œä¸‹æ ‡ï¼Œclickc æ˜¯åˆ—ä¸‹æ ‡ï¼‰ã€‚
    //
    //æ ¹æ®ä»¥ä¸‹è§„åˆ™ï¼Œè¿”å›ç›¸åº”ä½ç½®è¢«ç‚¹å‡»åå¯¹åº”çš„ç›˜é¢ï¼š
    //
    //å¦‚æœä¸€ä¸ªåœ°é›·ï¼ˆ'M'ï¼‰è¢«æŒ–å‡ºï¼Œæ¸¸æˆå°±ç»“æŸäº†- æŠŠå®ƒæ”¹ä¸º 'X' ã€‚
    //å¦‚æœä¸€ä¸ª æ²¡æœ‰ç›¸é‚»åœ°é›· çš„ç©ºæ–¹å—ï¼ˆ'E'ï¼‰è¢«æŒ–å‡ºï¼Œä¿®æ”¹å®ƒä¸ºï¼ˆ'B'ï¼‰ï¼Œå¹¶ä¸”æ‰€æœ‰å’Œå…¶ç›¸é‚»çš„ æœªæŒ–å‡º æ–¹å—éƒ½åº”è¯¥è¢«é€’å½’åœ°æ­éœ²ã€‚
    //å¦‚æœä¸€ä¸ª è‡³å°‘ä¸ä¸€ä¸ªåœ°é›·ç›¸é‚» çš„ç©ºæ–¹å—ï¼ˆ'E'ï¼‰è¢«æŒ–å‡ºï¼Œä¿®æ”¹å®ƒä¸ºæ•°å­—ï¼ˆ'1' åˆ° '8' ï¼‰ï¼Œè¡¨ç¤ºç›¸é‚»åœ°é›·çš„æ•°é‡ã€‚
    //å¦‚æœåœ¨æ­¤æ¬¡ç‚¹å‡»ä¸­ï¼Œè‹¥æ— æ›´å¤šæ–¹å—å¯è¢«æ­éœ²ï¼Œåˆ™è¿”å›ç›˜é¢ã€‚



    //   ["E","E","E","E","E"]      --->        ["B","1","E","1","B"]
    //   ["E","E","M","E","E"]                  ["B","1","M","1","B"]
    //   ["E","E","E","E","E"]                  ["B","1","1","1","B"]
    //   ["E","E","E","E","E"]                  ["B","B","B","B","B"]

    // click = [3,0]


    int[][] dirs = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}}; // å‘¨è¾¹8ä¸ªæ–¹å‘
    public char[][] updateBoard(char[][] board, int[] click) {
        int x = click[0] , y = click[1];

        // é‡åˆ°åœ°é›·äº†ï¼Œç›´æ¥return
        if (board[x][y] == 'M'){
            board[x][y] = 'X';
            return board;
        }

        // å°†å‘¨è¾¹çš„ E å˜æˆ B ï¼Œ åœ°é›· M é™„è¿‘çš„ä¸èƒ½å˜
        dfs(board , x , y);

        return board;
    }

    private void dfs(char[][] board, int x, int y) {

        // åˆ¤æ–­å½“å‰ç‚¹å‘¨å›´çš„ åœ°é›·æ•°é‡
        int count = 0;
        for (int i = 0; i < 8; i++) {
            int a = x + dirs[i][0] , b = y + dirs[i][1];
            if (a >= 0 && a < board.length && b >= 0 && b < board[0].length && board[a][b] == 'M') count++;
        }

        // å¦‚æœå­˜åœ¨åœ°é›·ï¼Œå°±æ˜¾ç¤ºæ•°å­—ï¼Œä¸ç»§ç»­æŒ–äº†
        if (count > 0) {
            board[x][y] = (char)(count + '0');
            return;
        }


        // ä¸å­˜åœ¨åœ°é›·ï¼Œæ”¹å˜å½“å‰å€¼ï¼Œé€’å½’çš„éå†å‘¨å›´çš„èŠ‚ç‚¹
        board[x][y] = 'B';
        for (int i = 0; i < 8; i++) {
            int a = x + dirs[i][0] , b = y + dirs[i][1];
            if (a >= 0 && a < board.length && b >= 0 && b < board[0].length && board[a][b] == 'E') dfs(board , a , b);
        }

    }




    // bfs è§£æ³•
    //ä¸æ ‘çš„ BFS ä¸ä¸€æ ·ï¼ˆæ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªçˆ¶äº²èŠ‚ç‚¹ï¼‰ï¼Œæœ¬é¢˜å›¾ä¸­çš„ç‚¹ä¼šç”±å¤šä¸ªç‚¹è¾¾åˆ°ï¼Œå› æ­¤éœ€è¦åŠ ä¸Š boolean[][] visited æ•°ç»„è®°å½•è®¿é—®æ ‡å¿—ï¼Œé˜²æ­¢æ¯ä¸ªç‚¹é‡å¤å…¥é˜Ÿè€Œè¶…æ—¶

    /*
    * class Solution {
    // å®šä¹‰ 8 ä¸ªæ–¹å‘
    int[] dx = {-1, 1, 0, 0, -1, 1, -1, 1};
    int[] dy = {0, 0, -1, 1, -1, 1, 1, -1};

    public char[][] updateBoard(char[][] board, int[] click) {
        // 1. è‹¥èµ·ç‚¹æ˜¯é›·ï¼Œæ¸¸æˆç»“æŸï¼Œç›´æ¥ä¿®æ”¹ board å¹¶è¿”å›ã€‚
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            board[x][y] = 'X';
            return board;
        }

        // 2. è‹¥èµ·ç‚¹æ˜¯ç©ºåœ°ï¼Œåˆ™å°†èµ·ç‚¹å…¥é˜Ÿï¼Œä»èµ·ç‚¹å¼€å§‹å‘ 8 é‚»åŸŸçš„ç©ºåœ°è¿›è¡Œå®½åº¦ä¼˜å…ˆæœç´¢ã€‚
        int m = board.length, n = board[0].length;
        boolean[][] visited = new boolean[m][n];
        visited[x][y] = true;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] {x, y});
        while (!queue.isEmpty()) {
            int[] point = queue.poll();
            int i = point[0], j = point[1];
            // åˆ¤æ–­ç©ºåœ° (i, j) å‘¨å›´æ˜¯å¦æœ‰é›·
            int cnt = 0;
            for (int k = 0; k < 8; k++) {
                int newX = i + dx[k];
                int newY = j + dy[k];
                if (newX < 0 || newX >= board.length || newY < 0 || newY >= board[0].length) {
                    continue;
                }
                if (board[newX][newY] == 'M') {
                    cnt++;
                }
            }
            // è‹¥ç©ºåœ° (i, j) å‘¨å›´æœ‰é›·ï¼Œåˆ™å°†è¯¥ä½ç½®ä¿®æ”¹ä¸ºé›·æ•°ï¼›å¦åˆ™å°†è¯¥ä½ç½®æ›´æ–°ä¸º â€˜Bâ€™ï¼Œå¹¶å°†å…¶ 8 é‚»åŸŸä¸­çš„ç©ºåœ°å…¥é˜Ÿï¼Œç»§ç»­è¿›è¡Œ bfs æœç´¢ã€‚
            if (cnt > 0) {
                board[i][j] = (char)(cnt + '0');
            } else {
                board[i][j] = 'B';
                for (int k = 0; k < 8; k++) {
                    int newX = i + dx[k];
                    int newY = j + dy[k];
                    if (newX < 0 || newX >= board.length || newY < 0 || newY >= board[0].length
                        || board[newX][newY] != 'E' || visited[newX][newY]) {
                        continue;
                    }
                    visited[newX][newY] = true;
                    queue.offer(new int[] {newX, newY});
                }
            }
        }
        return board;
    }
}

ä½œè€…ï¼šSweetiee ğŸ¬
é“¾æ¥ï¼šhttps://leetcode.cn/problems/minesweeper/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
    *
    * */


}
